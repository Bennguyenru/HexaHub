package com.dynamo.bob.pipeline;

import static org.apache.commons.io.FilenameUtils.normalize;

import java.io.File;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.zip.ZipEntry;
import java.util.zip.ZipOutputStream;

import org.apache.commons.io.FileUtils;
import org.apache.commons.io.FilenameUtils;

import com.dynamo.bob.CompileExceptionError;
import com.dynamo.bob.Platform;
import com.dynamo.bob.Project;
import com.dynamo.bob.fs.IResource;

public class BundleResourceUtil {

    private static final String extensionFilename = "ext.manifest";

    /**
     * Get a list of paths to extension directories in the project.
     * @param project
     * @return A list of paths to extension directories
     */
    static List<String> getExtensionFolders(Project project) {
        ArrayList<String> paths = new ArrayList<>();
        project.findResourcePaths("", paths);

        List<String> folders = new ArrayList<>();
        for (String p : paths) {
            File f = new File(p);
            if (f.getName().equals(extensionFilename)) {
                folders.add( "/" + f.getParent() ); // Return project absolute path
            }
        }
        return folders;
    }

    private static void mergeBundleMap(Map<String, IResource> into, Map<String, IResource> from) throws CompileExceptionError{

        Iterator<Map.Entry<String, IResource>> it = from.entrySet().iterator();
        while (it.hasNext()) {
            Map.Entry<String, IResource> entry = (Map.Entry<String, IResource>)it.next();
            String outputPath = entry.getKey();
            if (into.containsKey(outputPath)) {
                IResource inputA = into.get(outputPath);
                IResource inputB = entry.getValue();

                String errMsg = "Conflicting output bundle resource '" + outputPath + "â€˜ generated by the following input files: " + inputA.toString() + " <-> " + inputB.toString();
                throw new CompileExceptionError(inputB, 0, errMsg);
            } else {
                into.put(outputPath, entry.getValue());
            }
        }
    }

    private static String guessPlatformString(Project project) {
        String targetPlatform = project.option("platform", null);

        if (targetPlatform == null) {
            Platform hostPlatform = Platform.getHostPlatform();
            targetPlatform = hostPlatform.getPair();
        }

        return targetPlatform;
    }

    private static List<String> platformStringToFolderAlternatives(String platform) {
        List<String> alternatives = new ArrayList<String>();
        alternatives.add("common");

        String[] platformParts = platform.split("-");
        String arch = platformParts.length > 1 ? platformParts[0] : "";
        String os = platformParts.length > 1 ? platformParts[1] : platformParts[0];

        switch (os) {
        case "darwin":
            if (arch.equals("armv7")) {
                alternatives.add("ios");
                alternatives.add("armv7-ios");
            } else if (arch.equals("arm64")) {
                alternatives.add("ios");
                alternatives.add("arm64-ios");
            } else if (arch.equals("x86")) {
                alternatives.add("osx");
                alternatives.add("x86-osx");
            } else if (arch.equals("x86_64")) {
                alternatives.add("osx");
                alternatives.add("x86_64-osx");
            }
            break;

        case "android":
            alternatives.add("android");
            if (arch.equals("armv7")) {
                alternatives.add("armv7-android");
            } else if (arch.equals("arm64")) {
                alternatives.add("arm64-android");
            }
            break;

        case "linux":
            alternatives.add("linux");
            if (arch.equals("x86")) {
                alternatives.add("x86-linux");
            } else if (arch.equals("x86_64")) {
                alternatives.add("x86_64-linux");
            }
            break;

        case "win32":
            alternatives.add("windows");
            if (arch.equals("x86")) {
                alternatives.add("x86-windows");
            } else if (arch.equals("x86_64")) {
                alternatives.add("x86_64-windows");
            }
            break;

        case "web":
            alternatives.add("web");
            break;

        default:
            break;
        }

        return alternatives;
    }

    private static List<String> trimExcludePaths(List<String> excludes) {
        List<String> trimmedExcludes = new ArrayList<String>();
        for (String path : excludes) {
            trimmedExcludes.add(path.trim());
        }
        return trimmedExcludes;
    }

    /**
     * Collect bundle resources from a specific project path and a list of exclude paths.
     * @param project
     * @param platform String representing the target platform.
     * @param excludes A list of project relative paths for resources to exclude.
     * @return Returns a map with output paths as keys and the corresponding IResource that should be used as value.
     * @throws CompileExceptionError if a output conflict occurs.
     */
    public static Map<String, IResource> collectResources(Project project, String path, List<String> excludes) throws CompileExceptionError {
        if (excludes == null) {
            excludes = new ArrayList<>();
        }

        // Remove prefix slash if present
        /*
        if (!path.substring(0,1).equals("/")) {
            path = path.substring(1);
        }
        */

        HashMap<String, IResource> resources = new HashMap<String, IResource>();
        ArrayList<String> paths = new ArrayList<>();
        project.findResourcePaths(path.substring(1), paths);
        for (String p : paths) {
            String pathProjectAbsolute = "/" + p;
            if (!excludes.contains(pathProjectAbsolute)) {
                IResource r = project.getResource(p);
                String bundleRelativePath = pathProjectAbsolute.substring(path.length());
                resources.put(bundleRelativePath, r);
            }
        }

        return resources;
    }

    /**
     * Collect bundle resources based on a Project and a target platform string used to collect correct platform specific resources.
     * @param project
     * @param platform String representing the target platform.
     * @return Returns a map with output paths as keys and the corresponding IResource that should be used as value.
     * @throws CompileExceptionError if a output conflict occurs.
     */
    public static Map<String, IResource> collectResources(Project project, String platform) throws CompileExceptionError {

        Map<String, IResource> bundleResources = new HashMap<String, IResource>();
        List<String> bundleExcludeList = trimExcludePaths(Arrays.asList(project.getProjectProperties().getStringValue("project", "bundle_exclude_resources", "").split(",")));
        List<String> platformFolderAlternatives = platformStringToFolderAlternatives(platform);

        // Project specific bundle resources
        String bundleResourcesPath = project.getProjectProperties().getStringValue("project", "bundle_resources", "").trim();
        if (bundleResourcesPath.length() > 0) {
            for (String platformAlt : platformFolderAlternatives) {
                Map<String, IResource> projectBundleResources = BundleResourceUtil.collectResources(project, FilenameUtils.concat(bundleResourcesPath, platformAlt + "/"), bundleExcludeList);
                mergeBundleMap(bundleResources, projectBundleResources);
            }
        }

        // Get bundle resources from extensions
        List<String> extensionFolders = getExtensionFolders(project);
        for (String extension : extensionFolders) {
            for (String platformAlt : platformFolderAlternatives) {
                Map<String, IResource> extensionBundleResources = BundleResourceUtil.collectResources(project, FilenameUtils.concat(extension, "res/" + platformAlt + "/"), bundleExcludeList);
                mergeBundleMap(bundleResources, extensionBundleResources);
            }
        }

        return bundleResources;
    }

    /**
     * Collect bundle resources based on a Project, will automatically retrieve the target platform to collect correct platform specific resources.
     * @param project
     * @return Returns a map with output paths as keys and the corresponding IResource that should be used as value.
     * @throws CompileExceptionError if a output conflict occurs.
     */
    public static Map<String, IResource> collectResources(Project project) throws CompileExceptionError {
        return collectResources(project, guessPlatformString(project));
    }

    /**
     * Write a map of bundle resources to a specific disk directory.
     * @param resources Map of resources to write to disk.
     * @param directory File object pointing to a output directory.
     * @throws IOException
     */
    public static void writeResourcesToDirectory(Map<String, IResource> resources, File directory) throws IOException {
        Iterator<Map.Entry<String, IResource>> it = resources.entrySet().iterator();
        while (it.hasNext()) {
            Map.Entry<String, IResource> entry = (Map.Entry<String, IResource>)it.next();
            File outputFile = new File(directory, entry.getKey());
            outputFile.getParentFile().mkdirs();
            FileUtils.writeByteArrayToFile(outputFile, entry.getValue().getContent());
        }
    }

    /**
     * Write a map of bundle resources to a Zip output stream.
     * @param resources Map of resources to write to disk.
     * @param zipOutputStream A ZipOutputStream where bundle resources should be written as Zip entries.
     * @throws IOException
     */
    public static void writeResourcesToZip(Map<String, IResource> resources, ZipOutputStream zipOutputStream) throws IOException {
        Iterator<Map.Entry<String, IResource>> it = resources.entrySet().iterator();
        while (it.hasNext()) {
            Map.Entry<String, IResource> entry = (Map.Entry<String, IResource>)it.next();
            ZipEntry ze = new ZipEntry(normalize(entry.getKey(), true));
            zipOutputStream.putNextEntry(ze);
            zipOutputStream.write(entry.getValue().getContent());
        }
    }

}
