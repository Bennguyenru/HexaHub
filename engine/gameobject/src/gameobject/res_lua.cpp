// Copyright 2020-2022 The Defold Foundation
// Copyright 2014-2020 King
// Copyright 2009-2014 Ragnar Svensson, Christian Murray
// Licensed under the Defold License version 1.0 (the "License"); you may not use
// this file except in compliance with the License.
// 
// You may obtain a copy of the License, together with FAQs at
// https://www.defold.com/license
// 
// Unless required by applicable law or agreed to in writing, software distributed
// under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR
// CONDITIONS OF ANY KIND, either express or implied. See the License for the
// specific language governing permissions and limitations under the License.

#include <dlib/dstrings.h>
#include <dlib/log.h>

#include <dmsdk/resource/resource.h>
#include "res_lua.h"
#include "gameobject_script.h"

namespace dmGameObject
{
    void PatchLuaBytecode(dmLuaDDF::LuaModule* lua_module)
    {
#if defined(LUA_BYTECODE_ENABLE_32)

        dmLuaDDF::LuaSource *source = lua_module->m_Source;
        dmLogInfo("PatchLuaBytecode %s", source->m_Filename);

        // get the 64-bit bytecode
        char* bc = (char*)source->m_Bytecode.m_Data;
        uint32_t bc_size = source->m_Bytecode.m_Count;

        // get the 32-bit bytecode delta generated by bob
        // apply the delta to the 64-bit bytecode
        const char* delta = (const char*)source->m_Delta.m_Data;
        uint32_t delta_size = source->m_Bytecode64.m_Count;
        dmLogInfo("PatchLuaBytecode delta size: %d bc_size: %d", delta_size, bc_size);
        uint32_t i = 0;
        while (i < delta_size) {
            
            // get the index
            // for bytecode with size less than 256 bytes we store the index as a byte
            // for bytecode with size less than 65536 bytes we store the index as a short
            // for bytecode with a larger size than that we store the index as an int
            uint32_t index = (unsigned char)delta[i++];
            if (bc_size > 255)
            {
                index += ((unsigned char)delta[i++]) << 8;
            }
            if (bc_size > 65535)
            {
                index += ((unsigned char)delta[i++]) << 16;
                index += ((unsigned char)delta[i++]) << 24;
            }

            // read the delta and apply it to the 64-bit bytecode
            unsigned char diff = (unsigned char)delta[i++];
            bc[index] -= diff;
        }

        dmLogInfo("PatchLuaBytecode DONE %s", source->m_Filename);
#elif defined(LUA_BYTECODE_ENABLE_64)
        // no-op 
        dmLogInfo("PatchLuaBytecode 64 bit %s", source->m_Filename);
#endif
        dmLogInfo("PatchLuaBytecode no-op");
    }


    static dmResource::Result ResLuaCreate(const dmResource::ResourceCreateParams& params)
    {
        dmLogInfo("ResLuaCreate");
        dmLuaDDF::LuaModule* lua_module = 0;
        dmDDF::Result e = dmDDF::LoadMessage<dmLuaDDF::LuaModule>(params.m_Buffer, params.m_BufferSize, &lua_module);
        if ( e != dmDDF::RESULT_OK )
            return dmResource::RESULT_FORMAT_ERROR;

        PatchLuaBytecode(lua_module);

        LuaScript* lua_script = new LuaScript(lua_module);
        params.m_Resource->m_Resource = lua_script;
        params.m_Resource->m_ResourceSize = sizeof(LuaScript) + params.m_BufferSize - lua_script->m_LuaModule->m_Source.m_Script.m_Count;
        return dmResource::RESULT_OK;
    }

    static dmResource::Result ResLuaDestroy(const dmResource::ResourceDestroyParams& params)
    {
        dmLogInfo("ResLuaDestroy");
        LuaScript* script = (LuaScript*) params.m_Resource->m_Resource;
        dmDDF::FreeMessage(script->m_LuaModule);
        delete script;
        return dmResource::RESULT_OK;
    }

    static dmResource::Result ResLuaRecreate(const dmResource::ResourceRecreateParams& params)
    {
        dmLogInfo("ResLuaRecreate");
        dmLuaDDF::LuaModule* lua_module = 0;
        dmDDF::Result e = dmDDF::LoadMessage<dmLuaDDF::LuaModule>(params.m_Buffer, params.m_BufferSize, &lua_module);
        if ( e != dmDDF::RESULT_OK )
            return dmResource::RESULT_FORMAT_ERROR;

        PatchLuaBytecode(lua_module);

        ModuleContext* module_context = (ModuleContext*) params.m_Context;
        uint32_t context_count = module_context->m_ScriptContexts.Size();
        for (uint32_t i = 0; i < context_count; ++i) {
            dmScript::HContext script_context = module_context->m_ScriptContexts[i];
            dmScript::ReloadModule(script_context, &lua_module->m_Source, params.m_Resource->m_NameHash);
        }
        LuaScript* lua_script = (LuaScript*) params.m_Resource->m_Resource;
        params.m_Resource->m_ResourceSize = sizeof(LuaScript) + params.m_BufferSize - lua_script->m_LuaModule->m_Source.m_Script.m_Count;
        dmDDF::FreeMessage(lua_script->m_LuaModule);
        lua_script->m_LuaModule = lua_module;
        return dmResource::RESULT_OK;
    }

    static dmResource::Result RegisterResourceTypeLua(dmResource::ResourceTypeRegisterContext& ctx)
    {
        // The engine.cpp creates the contexts for our built in types.
        void** context = ctx.m_Contexts->Get(ctx.m_NameHash);
        assert(context);
        return dmResource::RegisterType(ctx.m_Factory,
                                           ctx.m_Name,
                                           *context,
                                           0,
                                           ResLuaCreate,
                                           0,
                                           ResLuaDestroy,
                                           ResLuaRecreate);
    }
}

DM_DECLARE_RESOURCE_TYPE(ResourceTypeLua, "luac", dmGameObject::RegisterResourceTypeLua, 0);
