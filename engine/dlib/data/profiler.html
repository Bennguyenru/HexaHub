<html>
    <head>
        <title>Dynamo Profiler</title>
        <style type="text/css">
            body {
                background: #fff;
                font-family: Arial, Helvetica, Helvetica Neue, Verdana, sans-serif;
                font-size: 12px;
                line-height: 18px;
            }

            table {
                font-family: Arial, Helvetica, Helvetica Neue, Verdana, sans-serif;
                font-size: 12px;
                line-height: 18px;
            }

            #frames {
                width: 1000px;
                border-color: rgb(100, 100, 100);
                border-width: 1px;
                border-style: solid;
            }

            #frame {
                width: 1000px;
                height: 1000px;
                border-color: #888;
                border-width: 1px;
                border-style: solid;
            }

            #plot {
                width: 1000px;
                height: 400px;
                border-color: #888;
                border-width: 1px;
                border-style: solid;
                padding: 16px;
            }

            div.frameblock_green {
                background: -webkit-gradient(linear, left top, left bottom, from(hsl(130, 60%, 50%)), to(hsl(130, 20%, 50%)));

                float: left;
                border-color: rgb(100,100,100);
                border-style: solid;
                border-width: 1px;
                margin: -1px;
                padding: 0;
            }

            div.frameblock_red {
                background: -webkit-gradient(linear, left top, left bottom, from(hsl(0, 60%, 50%)), to(hsl(0, 20%, 50%)));

                float: left;
                border-color: rgb(100,100,100);
                border-style: solid;
                border-width: 1px;
                margin: -1px;
                padding: 0;
            }

            div.square {
                width: 16px;
                height: 16px;
                float: left;
                margin-right: 4px;
            }

            table.prof-table {
              border: 1;
              border-width: 1px;
              border-color: #888;
              border-style: solid;
              border-spacing: 0px;
              border-collapse:collapse;
              color: #333;
            }

            th.prof-table {
              text-align: left;
              border-width: 1px;
              border-color: #888;
              border-style: solid;
              padding: 4px;
            }

            td.prof-table {
              padding: 4px;
              border-width: 1px;
              border-color: #888;
              border-style: solid;
            }

            td.first {
              _width: 120px;
              text-align: left;
              _font-weight: bold;
            }

            td.second {
              width: 90px;
              text-align: left;
            }

            td.even {
              background-color: #fff;
            }

            td.odd {
              background-color: rgb(233, 233, 233);
            }

        </style>
        <script type="text/javascript">

            // TODO: This is not true on windows...
            // Add metainfo chunk?
            var ticksPerSecond = 1000.0; // NOTE: We use ms internally
            var stringTable = {};
            var frames = [];

            // If running another server change base_url to value below, eg when testing
            //var base_url = 'http://localhost:8002/'
            var base_url = '/'
            var request = new XMLHttpRequest();

            var capturedFrameCount = 0;
            var capturedSamplesData = [];

            var scopeColors = {};
            var counterColors = {};

            var plotSamples = {};
            var plotCounters = {};

            function capture(){
                frames = [];
                capturedFrameCount = 0;
                capturedSamplesData = [];
                request.open('GET', base_url + 'strings', true);
                request.overrideMimeType('text/plain; charset=x-user-defined');
                request.onreadystatechange = handler;
                request.send();
            }

            function getChunk(url){
                request.open('GET', base_url + url, true);
                request.overrideMimeType('text/plain; charset=x-user-defined');
                request.onreadystatechange = handler;
                request.send();
            }

            readUInt32 = function(data, offset){
                var a1 = data.charCodeAt(offset + 3) & 0xff;
                var a2 = data.charCodeAt(offset + 2) & 0xff;
                var a3 = data.charCodeAt(offset + 1) & 0xff;
                var a4 = data.charCodeAt(offset + 0) & 0xff;
                return (a1 << 24) + (a2 << 16) + (a3 << 8) + a4;
            }

            readUInt16 = function(data, offset){
                var a1 = data.charCodeAt(offset + 1) & 0xff;
                var a2 = data.charCodeAt(offset + 0) & 0xff;
                return (a1 << 8) + a2;
            }

            readPtr = function(data, offset, size) {
                // no support for pointer arithmetic here anyway, so just use the string.
                return data.substring(offset, offset + size);
            }

            function loadProfile(d, table) {
                var ptrSize = readUInt16(d, 0);
                var samples = [];
                var sample_count = readUInt32(d, 2);
                var offset = 6;
                var frameTime = 0;
                for (var i = 0; i < sample_count; ++i) {
                    var name_id = readPtr(d, offset, ptrSize);
                    var scope = readPtr(d, offset + ptrSize, ptrSize);
                    offset += 2 * ptrSize;
                    var start = readUInt32(d, offset + 0);
                    var elapsed = readUInt32(d, offset + 4);
                    var thread_id = readUInt16(d, offset + 8);
                    var name = table[name_id];

                    var scope_name = table[scope];
                    offset += 4 * 4;

                    frameTime = Math.max(frameTime, elapsed / ticksPerSecond);

                    var s = {
                        scope_name: scope_name,
                        name: scope_name + "." + name,
                        start: start / ticksPerSecond,
                        elapsed: elapsed / ticksPerSecond
                    };
                    samples.push(s);
                }

                var scopes_data = [];
                var scope_count = readUInt32(d, offset);
                offset += 4;
                for (var i = 0; i < scope_count; ++i) {
                    var name_id = readPtr(d, offset, ptrSize);
                    var elapsed = readUInt32(d, offset + ptrSize);
                    var count = readUInt32(d, offset + ptrSize + 4);
                    offset += ptrSize + 2 * 4;
                    var name = table[name_id];

                    scopes_data[name] = {
                        elapsed: elapsed,
                        count: count
                    };
                }

                var counters_data = [];
                var counter_count = readUInt32(d, offset);
                offset += 4;
                for (var i = 0; i < counter_count; ++i) {
                    var name_id = readPtr(d, offset, ptrSize);
                    var value = readUInt32(d, offset + ptrSize);
                    offset += (4 + ptrSize);
                    // if the pointer size is 8 bytes (eg on iOS 64 bit) the
                    // counters data struct gets padded with 4 additional bytes
                    if (ptrSize == 8) {
                      offset += 4;
                    }
                    var name = table[name_id];
                    counters_data[name] = {
                        value: value
                    };
                }

                return {
                    samples: samples,
                    frame_time: frameTime,
                    scopes_data: scopes_data,
                    counters_data: counters_data
                };
            }

            function loadStrings(d, table){
                var ptrSize = readUInt16(d, 4);
                var string_count = readUInt32(d, 6);
                var offset = 10;
                for (var i = 0; i < string_count; ++i) {
                    var id = readPtr(d, offset, ptrSize);
                    offset += ptrSize;
                    var len = readUInt16(d, offset);
                    var str = d.substring(offset + 2, offset + 2 + len);

                    table[id] = str;

                    offset += (len + 2);
                }
            }

            function handler(evtXHR){
                if (request.readyState == 4) {
                    if (request.status == 200) {
                        var d = request.responseText;

                        var type = d.substring(0, 4);
                        if (type == "PROF") {
                            capturedFrameCount += 1;

                            if (capturedFrameCount % 10 == 0)
                                console.log("Capturing..." + capturedFrameCount);

                            capturedSamplesData.push(d.substring(4));
                            if (capturedFrameCount < 20) {
                                getChunk('profile')
                            }
                            else {

                                for (var i in capturedSamplesData) {
                                    var prof = loadProfile(capturedSamplesData[i], stringTable);
                                    frames.push(prof);
                                }
                                captureDone();
                            }
                        }
                        else if (type == "STRS") {
                            loadStrings(d, stringTable);
                            getChunk('profile');
                        }
                        else {
                            alert("Unknown chunk type: " + type);
                        }
                    }
                    else {
                        alert("Failed to load data");
                    }
                }
            }

            function roundupAxisStep(value){
                var mag = Math.max(1, Math.pow(10, Math.round(Math.log(value) / Math.log(10) + 0.5)));
                var factors = [0.1, 0.25, 0.5, 1];
                for (var i in factors) {
                    if (value / mag <= factors[i])
                        return factors[i] * mag;
                }
                return mag;
            }

            function newPlotGraph(canvas){
                var instance = {};
                instance.canvas = canvas;

                instance.draw = function(){
                    var canvas = instance.canvas;
                    var ctx = canvas.getContext("2d");
                    var w = canvas.width;
                    var h = canvas.height;

                    ctx.font = "11px Arial;"
                    ctx.clearRect(0, 0, w, h);

                    ctx.save();

                    var max_sample = 1;
                    var max_counter = 0;
                    for (var i in frames) {
                        var f = frames[i];
                        for (var j in f.samples) {
                            var s = f.samples[j];
                            if (plotSamples[s.name]) {
                                max_sample = Math.max(max_sample, s.elapsed);
                            }
                        }

                        for (var name in f.counters_data) {
                            var cd = f.counters_data[name];
                            if (plotCounters[name]) {
                                max_counter = Math.max(max_counter, cd.value);
                            }
                        }
                    }

                    ctx.translate(0, 16);
                    h -= 32;

                    max_counter = Math.max(10, max_counter);
                    max_counter = Math.round(max_counter / max_sample + 0.5) * max_sample;

                    var margin = 60;

                    var font_height = 16;

                    var preferred_ytick1 = max_sample / 7;
                    var ytick1 = roundupAxisStep(preferred_ytick1);
                    max_sample = Math.round(max_sample / ytick1 + 0.5) * ytick1;
                    var nysteps1 = max_sample / ytick1 + 1;

                    var preferred_ytick2 = max_counter / (nysteps1 - 1); // -1 to round up
                    var ytick2 = roundupAxisStep(preferred_ytick2);
                    max_counter = ytick2 * (nysteps1 - 1);

                    for (var i = 0; i < nysteps1; i++) {
                        var y_px1 = h - h * i * ytick1 / max_sample;
                        ctx.fillStyle = "rgb(60, 60, 60)";
                        // Floating point rounding trix: 10 * ... / 10, avoid 0.70000001...
                        ctx.fillText((10 * i * ytick1) / 10 + "ms", 0, y_px1 + 2);
                        ctx.fillStyle = "rgb(190, 190, 190)";
                        ctx.fillRect(margin, y_px1 - 1, w - margin * 2, 1);

                        ctx.fillStyle = "rgb(60, 60, 60)";
                        // Floating point rounding trix: 10 * ... / 10, avoid 0.70000001...
                        ctx.fillText((10 * i * ytick2) / 10, w - 50, y_px1 + 2);
                    }

                    ctx.translate(margin, 0);
                    w -= margin * 2;
                    var xstep = 1;
                    var min_xstep_px = 40;
                    while (w / (frames.length / xstep) < min_xstep_px) {
                        xstep = Math.round(xstep / 5 + 1) * 5;
                    }

                    var i = 0;
                    while (i < frames.length) {
                        x = w * i / (frames.length - 1)
                        ctx.fillStyle = "rgb(190, 190, 190)";
                        ctx.fillRect(x, 0, 1, h);
                        ctx.fillStyle = "rgb(60, 60, 60)";
                        ctx.fillText(i, x, h + 16);
                        i += xstep;
                    }

                    for (var name in plotSamples) {
                        if (plotSamples[name] != true)
                            continue;

                        var scope_name = name.substring(0, name.indexOf("."))
                        ctx.strokeStyle = scopeColors[scope_name];
                        ctx.beginPath();
                        var x = 0;
                        var first = true;
                        for (var i in frames) {
                            var f = frames[i];
                            var sum = 0;
                            for (var j in f.samples) {
                                var s = f.samples[j];
                                if (s.name == name) {
                                    sum += s.elapsed;
                                }
                            }

                            var x = w * i / (frames.length - 1);
                            var y = h - h * sum / max_sample;
                            if (first)
                                ctx.moveTo(x, y);
                            else
                                ctx.lineTo(x, y);
                            first = false;
                        }
                        ctx.stroke();
                    }

                    for (var name in plotCounters) {
                        if (plotCounters[name] != true)
                            continue;

                        ctx.strokeStyle = counterColors[name];
                        ctx.beginPath();
                        var x = 0;
                        var first = true;
                        for (var i in frames) {
                            var f = frames[i];
                            var cd = f.counters_data[name];
                            if (cd == undefined)
                                continue;

                            var x = w * i / (frames.length - 1);
                            var y = h - h * cd.value / max_counter;
                            if (first)
                                ctx.moveTo(x, y);
                            else
                                ctx.lineTo(x, y);
                            first = false;
                        }
                        ctx.stroke();
                    }

                    ctx.restore();
                }

                return instance;
            }

            function newSamplesGraph(canvas){
                var instance = {};
                var sampleNamesWidth = 200;
                var offsetX = 0;
                var lastX = 10;
                var dragging = false;
                var currentFrame = undefined;
                var frameLen = 20;

                instance.canvas = canvas;
                canvas.onmousedown = function(evt){
                    dragging = true;
                    lastX = evt.clientX;
                }

                document.onmouseup = function(evt){
                    dragging = false;
                }

                document.onmousemove = function(evt){
                    if (!dragging)
                        return;

                    var dx = evt.clientX - lastX;
                    offsetX += dx;
                    offsetX = Math.min(0, offsetX);
                    lastX = evt.clientX;

                    instance.draw(currentFrame);
                };

                document.onkeydown = function(evt){
                    if (evt.keyCode == 187)
                        frameLen -= 0.5;
                    else
                        if (evt.keyCode == 189)
                            frameLen += 0.5;
                    frameLen = Math.max(0.5, frameLen);
                    instance.draw(currentFrame);
                }

                instance.draw = function(frame){
                    currentFrame = frame;
                    var index = 0;
                    var sampleNames = {}
                    for (var i in frame.samples) {
                        var sample = frame.samples[i];
                        if (sampleNames[sample.name] == undefined) {
                            sampleNames[sample.name] = {
                                index: index
                            };
                            index += 1
                        }
                    }

                    var y0 = 10;
                    var dy = 20;

                    var canvas = instance.canvas;
                    if (canvas.getContext) {
                        var ctx = canvas.getContext("2d");
                        var w = canvas.width;
                        var h = canvas.height;

                        ctx.font = "bold 11px Arial;"
                        ctx.clearRect(0, 0, w, h);

                        // Reset
                        ctx.shadowOffsetX = 0;
                        ctx.shadowOffsetY = 0;
                        ctx.shadowBlur = 0;
                        ctx.shadowColor = 'rgba(0, 0, 0, 0)';

                        y0 = 30;
                        var index = 0;
                        ctx.fillStyle = "rgb(243, 243, 243)";
                        for (var i in sampleNames) {
                            var s = sampleNames[i];
                            if (index++ % 2 == 0)
                                ctx.fillRect(0, y0 + s.index * dy - 2, w, 20);
                        }
                        y0 = 12;

                        ctx.save();
                        ctx.beginPath();
                        ctx.rect(sampleNamesWidth + 16, 0, w, h);
                        ctx.clip();

                        x0 = sampleNamesWidth + 16;
                        w = w - sampleNamesWidth - 16;

                        ctx.translate(offsetX, 0);

                        ctx.fillStyle = "rgb(190, 190, 190)";
                        ctx.strokeStyle = ctx.fillStyle;
                        var step = 1;
                        if (frameLen < 2) {
                            step = Math.max(0.1, Math.round(10 * frameLen / 5.0) / 10);
                        }
                        else {
                            step = Math.max(1, Math.round(frameLen / 5.0));
                        }

                        for (var i = 0; i <= 200; i += step / 2) {
                            ctx.fillRect(x0 + w * (i) / frameLen, 0, 1, h);
                        }

                        ctx.fillStyle = "rgb(60, 60, 60)";
                        for (var i = 0; i <= 200; i += step) {
                            delta = 4;
                            var x = Math.round(i * 10) / 10;
                            ctx.fillText(x + "ms", x0 + 6 + w * i / frameLen - 6 + delta, y0);
                        }

                        y0 = 30;

                        ctx.fillStyle = "rgb(0,0,200)";
                        ctx.strokeStyle = "rgb(50, 50, 50)";

                        ctx.shadowOffsetX = 2;
                        ctx.shadowOffsetY = 2;
                        ctx.shadowBlur = 2;
                        ctx.shadowColor = 'rgba(20, 20, 20, 0.55)';

                        var lasth = -1;
                        var last_style = "";
                        for (var i in frame.samples) {
                            var sample = frame.samples[i];

                            var style = scopeColors[sample.scope_name];
                            if (last_style != style) {
                                last_style = style;
                                ctx.fillStyle = style;
                            }
                            ctx.fillRect(x0 + w * sample.start / frameLen, y0 + sampleNames[sample.name].index * dy + 0, w * sample.elapsed / frameLen, 14);
                        }

                        ctx.restore();
                        ctx.shadowOffsetX = 0;
                        ctx.shadowOffsetY = 0;
                        ctx.shadowBlur = 0;
                        ctx.shadowColor = 'rgba(0, 0, 0, 0)';
                        ctx.fillStyle = "rgb(50,50,50)";
                        ctx.font = "11px Arial;"

                        for (var name in sampleNames) {
                            var s = sampleNames[name];
                            var metrics = ctx.measureText(name);
                            ctx.fillText(name, sampleNamesWidth - metrics.width, s.index * dy + y0 + 12);
                        }
                    }
                }
                return instance;
            }

            function newFramesGraph(placeholder){
                var instance = {};

                instance.placeholder = placeholder;

                instance.onframe = function(){
                }

                instance.draw = function(frames){
                    while (instance.placeholder.hasChildNodes()) {
                        instance.placeholder.removeChild(instance.placeholder.firstChild);
                    }

                    var time_div = document.createElement("div");
                    var w = instance.placeholder.offsetWidth;
                    var h = instance.placeholder.offsetHeight;
                    var client_h = instance.placeholder.clientHeight;

                    time_div.style.float = "left";
                    time_div.style.width = "60px";
                    time_div.style.height = h;
                    time_div.style.position = "absolute";
                    time_div.style.top = instance.placeholder.offsetHeight - 10;
                    time_div.innerHTML = "0ms";

                    var boxes_div = document.createElement("div");
                    boxes_div.style.float = "left";
                    boxes_div.style.position = "absolute";
                    boxes_div.style.left = 60;
                    boxes_div.style.width = w - 60;
                    boxes_div.style.height = h;

                    instance.placeholder.appendChild(time_div)
                    instance.placeholder.appendChild(boxes_div)

                    var max_frame = 0;
                    for (var i in frames) {
                        max_frame = Math.max(max_frame, frames[i].frame_time);
                    }

                    max_frame = Math.round(max_frame + 0.5);
                    time_div.innerHTML = max_frame + "ms";

                    var total_used = 0;
                    for (var i in frames) {
                        var node = document.createElement("div");
                        node.frameNumber = i;
                        node.onmousedown = function(evt){
                            instance.onframe(evt.target.frameNumber);
                        };
                        var frameTime = frames[i].frame_time;
                        var class_ = "frameblock_green";
                        if (frameTime > 1000.0 / 60.0)
                            class_ = "frameblock_red";

                        var box_w = Math.round(boxes_div.offsetWidth / frames.length);
                        if (i == frames.length - 1)
                            box_w = boxes_div.offsetWidth - total_used
                        total_used += box_w;

                        node.setAttribute("class", class_);
                        node.style.width = box_w + "px";
                        node.style.height = client_h * frameTime / max_frame + "px";
                        boxes_div.appendChild(node)
                    }
                }

                return instance;
            }

            var framesGraph = undefined;
            var samplesGraph = undefined;
            var plotGraph = undefined;

            function updateScopesTable(frame){
                var node = document.getElementById("scopes-table");
                var html = '<th class="prof-table">Scope</th><th class="prof-table">Time(ms)</th><tr/>';

                var template = '<td class="prof-table %eo first"><div class="square" style="background-color: %color"></div>%name</td><td class="prof-table %eo second">%e</td><tr/>';

                var i = 0;
                var even_odd = ["odd", "even"];
                for (var name in frame.scopes_data) {
                    var sd = frame.scopes_data[name];
                    var e = Math.round(100 * sd.elapsed / ticksPerSecond) / 100;
                    var eo = even_odd[i % 2];
                    html += template.replace(/%eo/g, eo).replace(/%e/g, e).replace(/%name/g, name).replace(/%color/g, scopeColors[name]);
                    ++i;
                }
                node.innerHTML = html;
            }

            function onSamplesCheckbox(self){
                plotSamples[self.id] = self.checked;
                plotGraph.draw();
            }

            function onCountersCheckbox(self){
                plotCounters[self.id] = self.checked;
                plotGraph.draw();
            }

            function updateSamplesTable(frame){
                var node = document.getElementById("samples-table");
                var html = '<th class="prof-table">Sample</th><th class="prof-table">Time(ms)</th><th class="prof-table">#</th><th class="prof-table"></th><tr/>';

                var sum = {}
                for (var i in frame.samples) {
                    var s = frame.samples[i];

                    if (sum[s.name] == undefined) {
                        // First sample
                        sum[s.name] = [s.elapsed, 1, s.scope_name, s];
                    } else {
                        var tmp = sum[s.name];
                        var last_sample = tmp[3];
                        var end_last = last_sample.start + last_sample.elapsed;
                        if (s.start >= last_sample.start && s.start < end_last) {
                            // Probably recursion. The sample is overlapping the previous.
                            // Ignore this sample.
                        } else {
                            tmp = [tmp[0] + s.elapsed, tmp[1] + 1, tmp[2], s];
                            sum[s.name] = tmp;
                        }
                    }
                }

                var template = '<td class="prof-table %eo first"><div class="square" style="background-color: %color"></div>%name</td><td class="prof-table %eo second">%e</td></td><td class="prof-table %eo second"> %count</td><td class="prof-table %eo"><input %checked onchange="onSamplesCheckbox(this);" id="%name" type="checkbox"/></td><tr/>';
                var i = 0;
                var even_odd = ["odd", "even"];
                for (var name in sum) {
                    var tmp = sum[name];
                    var e = Math.round(100.0 * tmp[0]) / 100.0;
                    // Skip "small" samples (sum of)
                    if (e < 0.03)
                        continue;
                    var eo = even_odd[i % 2];
                    var checked = "";
                    if (plotSamples[name] == true)
                        checked = 'checked="true"';
                    html += template.replace(/%eo/g, eo).replace(/%e/g, e).replace(/%name/g, name).replace(/%color/g, scopeColors[tmp[2]]).replace(/%count/g, tmp[1]).replace(/%checked/g, checked);
                    ++i;
                }
                node.innerHTML = html;
            }

            function updateCountersTable(frame){
                var node = document.getElementById("counters-table");
                var html = '<th class="prof-table">Counter</th><th class="prof-table">Count</th><th class="prof-table"></th><tr/>';

                var template = '<td class="prof-table %eo first"><div class="square" style="background-color: %color"></div>%name</td><td class="prof-table %eo second">%value</td><td class="prof-table %eo"><input %checked onchange="onCountersCheckbox(this);" id="%name" type="checkbox"/></td><tr/>';

                var i = 0;
                var even_odd = ["odd", "even"];
                for (var name in frame.counters_data) {
                    var cd = frame.counters_data[name];
                    var c = cd.value;
                    var eo = even_odd[i % 2];
                    var checked = "";
                    if (plotCounters[name] == true)
                        checked = 'checked="true"';
                    html += template.replace(/%eo/g, eo).replace(/%value/g, c).replace(/%name/g, name).replace(/%color/g, counterColors[name]).replace(/%checked/g, checked);
                    ++i;
                }
                node.innerHTML = html;
            }

            function calculatePalette(){
                scopeColors = {};
                counterColors = {};

                var color_index1 = 0;
                var color_index2 = 0;
                for (var i in frames) {
                    var f = frames[i];
                    for (var name in f.scopes_data) {
                        var sd = f.scopes_data[name];
                        if (scopeColors[name] == undefined) {
                            scopeColors[name] = color_index1++;
                        }
                    }

                    for (var name in f.counters_data) {
                        var cd = f.counters_data[name];
                        if (counterColors[name] == undefined) {
                            counterColors[name] = color_index2++;
                        }
                    }
                }

                for (var name in scopeColors) {
                    scopeColors[name] = "hsl(" + 120 * scopeColors[name] / (color_index1 - 1) + ", 35%, 50%)";
                }

                for (var name in counterColors) {
                    counterColors[name] = "hsl(" + (180 + 120 * counterColors[name] / (color_index2 - 1)) + ", 35%, 50%)";
                }
            }

            function captureDone(){
                calculatePalette();

                framesGraph.draw(frames);
                samplesGraph.draw(frames[0]);
                plotGraph.draw();
                updateScopesTable(frames[0]);
                updateSamplesTable(frames[0]);
                updateCountersTable(frames[0]);
            }

            function clickFrame(i){
                samplesGraph.draw(frames[i]);
                updateScopesTable(frames[i]);
                updateSamplesTable(frames[i]);
                updateCountersTable(frames[i]);
            }

            function init(){
                var frames_node = document.getElementById("frames");
                framesGraph = newFramesGraph(frames_node);
                framesGraph.onframe = clickFrame;

                var frame_canvas_node = document.getElementById("frame-canvas");
                samplesGraph = newSamplesGraph(frame_canvas_node);

                var plot_canvas_node = document.getElementById("plot-canvas");
                plotGraph = newPlotGraph(plot_canvas_node);

                capture();
            }
        </script>
    </head>
    <body onload="init();">
        <div style="margin-bottom: 8px;">
            <input type="button" value="Capture" onclick="capture();">
            </input>
        </div>
        <div id="frames" style="height: 60px;">
        </div>
        <br/>
        <table border="0" style="border-spacing: 0px; _width: 1000px;">
            <tr>
                <td valign="top">
                    <table id="scopes-table" class="prof-table">
                        <th class="prof-table">
                            Scope
                        </th>
                        <th class="prof-table">
                            Time(ms)
                        </th>
                        <th class="prof-table">
                            Average(ms)
                        </th>
                        <tr/>
                    </table>
                </td>
                <td style="width: 20px">
                </td>
                <td valign="top" align="center">
                    <table id="samples-table" class="prof-table">
                        <th class="prof-table">
                            Sample
                        </th>
                        <th class="prof-table">
                            Time(ms)
                        </th>
                        <th class="prof-table">
                            Average(ms)
                        </th>
                    </table>
                </td>
                <td style="width: 20px">
                </td>
                <td valign="top" align="right">
                    <table id="counters-table" class="prof-table">
                        <th class="prof-table">
                            Counter
                        </th>
                        <th class="prof-table">
                            Amount
                        </th>
                        <th class="prof-table">
                        </th>
                    </table>
                </td>
            </tr>
        </table>
        <br/>
        <div id="plot">
            <canvas id="plot-canvas" style="float: left;" width="1000px" height="400px">
            </canvas>
        </div>
        <div id="frame" style="height: 1500px;">
            <canvas id="frame-canvas" style="float: left;" width="1000px" height="1500px">
            </canvas>
        </div>
    </body>
</html>
